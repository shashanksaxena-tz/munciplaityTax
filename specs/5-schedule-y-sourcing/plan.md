# Implementation Plan: Schedule Y - Multi-State Income Sourcing

**Branch**: `5-schedule-y-sourcing` | **Date**: 2025-11-28 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/5-schedule-y-sourcing/spec.md`

**Note**: This plan is generated by the implementation planning process. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Implement comprehensive multi-state income sourcing and apportionment for businesses operating in multiple jurisdictions. This feature enables businesses to calculate Schedule Y (Apportionment) using property, payroll, and sales factors with support for Joyce vs Finnigan elections, throwback/throwout rules, market-based sourcing for services, and four-factor formulas with double-weighted sales. Critical for 40%+ of business filers with multi-state operations.

**Key Capabilities:**
- Joyce vs Finnigan sales factor sourcing election
- Throwback/throwout rules for destination states without nexus
- Market-based sourcing for service revenue (modern trend)
- Cost-of-performance fallback for services
- Four-factor apportionment with double-weighted sales (Ohio default)
- Property factor with rental capitalization (8x annual rent)
- Payroll factor with remote employee allocation
- Sales factor with transaction-level sourcing
- Nexus tracking for throwback determination
- Multi-municipality support within Ohio
- Comprehensive audit trail

## Technical Context

**Language/Version**: TypeScript 5.x (frontend), Java 21 LTS (backend - Spring Boot 3.2.3)  
**Primary Dependencies**: 
- Frontend: React 18+, Vite, Tailwind CSS
- Backend: Spring Boot, Spring Cloud (service discovery, circuit breaking), PostgreSQL driver, Jackson (JSON)
- Testing: Jest/React Testing Library (frontend), JUnit 5/Mockito (backend)

**Storage**: PostgreSQL 16+ with multi-tenant schemas (schema-per-tenant isolation)  
**Testing**: Jest + React Testing Library (frontend), JUnit 5 + Mockito + Spring Boot Test (backend), integration tests for API contracts  
**Target Platform**: Web application (Linux server backend, modern browsers frontend)  
**Project Type**: Web application with microservices architecture  

**Performance Goals**: 
- API responses <200ms p95 for factor calculations
- Apportionment calculation <500ms for typical business (3 factors, 100 transactions)
- Support 1,000 concurrent users during tax filing season
- Handle up to 10,000 sales transactions per return

**Constraints**: 
- Must maintain multi-tenant data isolation (non-negotiable)
- Must provide complete audit trail for all calculations and elections
- Must support tenant-specific rule configuration (different municipalities may use different formulas)
- Must handle decimal precision for tax calculations (BigDecimal in Java, avoid floating point)
- Must integrate with existing rule engine (Spec 4)

**Scale/Scope**: 
- Support 50+ municipalities (tenants) each with 5,000-50,000 business filers
- Handle 10-50 states/municipalities per business for nexus tracking
- Store 5+ years of historical apportionment data per business
- Support 100+ apportionment rule variations (formula types, sourcing methods, throwback elections)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Microservices Architecture First ✅

**Service Placement**: This feature will be implemented in the **tax-engine-service** (existing) as apportionment is a core tax calculation capability. No new service required.

**Rationale**: Apportionment calculation is tightly coupled with tax liability computation. Both require rule engine access, decimal precision math, and audit trailing. Keeping them in the same service reduces latency and maintains transaction boundaries.

**API Boundaries**: 
- POST `/api/v1/apportionment/calculate` - Calculate apportionment factors
- GET `/api/v1/apportionment/{returnId}` - Retrieve Schedule Y
- PUT `/api/v1/apportionment/{returnId}/elections` - Update sourcing elections
- GET `/api/v1/apportionment/{returnId}/breakdown` - Get detailed factor breakdown
- POST `/api/v1/nexus/track` - Update nexus status for throwback

### II. Multi-Tenant Data Isolation ✅

**Schema-per-Tenant**: All apportionment tables (schedule_y, property_factor, payroll_factor, sales_factor, nexus_tracking) will be created in tenant-specific schemas (e.g., `dublin.schedule_y`, `columbus.schedule_y`).

**Tenant Context**: Every API call will include tenant identification via JWT claim. All queries will be scoped via `SET search_path = {tenant_schema}` or Spring Data tenant resolver.

**Rule Isolation**: Apportionment formulas, throwback elections, and sourcing methods will be stored in rule engine with tenant-specific overrides (Dublin may use Finnigan, Westerville may require Joyce).

**Compliance**: No cross-tenant data access possible. Audit logs will be tenant-scoped.

### III. Audit Trail Immutability ✅

**Append-Only Logs**: `apportionment_audit_log` table will track:
- Sourcing method elections (Joyce→Finnigan change)
- Factor recalculations (property value updated)
- Transaction additions (new sale added)
- Nexus status changes (new state nexus established)

**No Deletion**: Soft deletes only. If a business corrects a factor value, the old value remains in audit log with `change_type = FACTOR_RECALCULATED`.

**Retention**: 7+ year retention per IRS requirements.

**Chain of Custody**: Every Schedule Y modification will store before/after state with user ID, timestamp, and reason.

### IV. AI Transparency & Explainability ⚠️

**Partial Applicability**: This feature primarily handles manual business data entry (property values, payroll, sales). AI is NOT directly involved in apportionment calculation.

**If AI Extraction Applies**: If future integration with extraction-service pulls apportionment data from uploaded financial statements:
- Must store bounding boxes for extracted property/payroll/sales figures
- Must display confidence scores for extracted values
- Must allow human override with audit trail

**Current Scope**: Manual entry only, so AI transparency requirements deferred to future extraction integration.

### V. Security & Compliance First ✅

**Authentication**: All apportionment APIs require JWT authentication. No anonymous access.

**Authorization**: RBAC enforced:
- INDIVIDUAL filers: Can view/edit only their own Schedule Y
- AUDITOR: Can view all Schedule Y within their tenant, can override calculations with justification
- ADMIN: Can configure apportionment rules (formulas, sourcing methods)

**Data Protection**: 
- Sales transactions may include customer names (PII) - stored encrypted at rest
- No SSN/EIN in apportionment data (those are in separate taxpayer tables)
- Audit logs must NOT log full sales transaction details (log transaction IDs only)

**Compliance**: Follows Ohio R.C. 718 (municipal tax confidentiality) and IRS Pub 1075 (federal tax info safeguarding).

### VI. User-Centric Design ✅

**Progressive Disclosure**: 
- Default view shows simplified three-factor breakdown (Property %, Payroll %, Sales %)
- "Show Details" expands to line-by-line transaction sourcing
- Advanced options (Joyce election, throwback rules) behind "Advanced Settings" section
- Tooltips explain each factor: "Property factor includes land, buildings, and equipment values"

**Error Prevention**:
- Real-time validation: "Sales factor cannot exceed 100%"
- Warning: "Your property factor is 0% but you entered an Ohio office address - did you forget to enter property values?"
- Pre-submission check: "Sum of all state apportionment is 110% (expected 95-105%) - verify throwback rules"

**Transparency**: 
- Visual breakdown shows formula: `(20% + 42% + 50% + 50%) / 4 = 40.5%`
- Each factor clickable to see supporting data: "Property factor 20% = $2M Ohio / $10M total"
- Calculation history: "Apportionment changed from 35% (2023) to 40.5% (2024)"

**Accessibility**: WCAG 2.1 AA compliant - keyboard navigation, ARIA labels, screen reader support.

**Mobile-First**: Schedule Y form must be completable on mobile (375px+) - responsive layout, touch-friendly inputs.

### VII. Test Coverage & Quality Gates ✅

**Unit Tests**: 
- Apportionment formula calculation: 100% coverage (critical path)
- Throwback rule determination: 100% coverage
- Factor percentage calculation: 100% coverage
- Service sourcing logic: ≥90% coverage

**Integration Tests**:
- POST /api/v1/apportionment/calculate with various factor inputs → verify percentages
- Finnigan vs Joyce election → verify different denominators
- Throwback rule application → verify sales thrown back to origin state
- Market-based vs cost-of-performance → verify service revenue allocation

**Contract Tests**: 
- Apportionment API contract must be versioned and tested
- Frontend and tax-engine-service must maintain compatible schemas
- Rule engine integration contract (formula retrieval)

**End-to-End Tests**:
- Business user enters property/payroll/sales → sees Schedule Y with factors → submits return
- Multi-state business elects Finnigan → calculation uses all group sales
- Service firm with NY customer → market-based sourcing assigns 100% to NY

**Pre-Deployment Gates**: All tests pass + security scan + code review.

### Constitution Compliance: ✅ PASS

All principles satisfied. No violations requiring justification.

## Project Structure

### Documentation (this feature)

```text
specs/5-schedule-y-sourcing/
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0 output (apportionment methodologies research)
├── data-model.md        # Phase 1 output (entity definitions)
├── quickstart.md        # Phase 1 output (developer guide)
├── contracts/           # Phase 1 output (API contracts)
│   ├── apportionment-api.yaml         # REST API OpenAPI spec
│   ├── schedule-y-dto.ts              # TypeScript DTOs
│   └── factor-calculation-contract.md # Calculation logic contracts
└── tasks.md             # Phase 2 output (NOT created by this plan command)
```

### Source Code (repository root)

```text
# Web application structure (frontend + backend)

backend/
├── src/main/java/com/munitax/
│   ├── taxengine/
│   │   ├── apportionment/
│   │   │   ├── controller/
│   │   │   │   └── ApportionmentController.java       # REST endpoints
│   │   │   ├── service/
│   │   │   │   ├── ApportionmentService.java          # Business logic
│   │   │   │   ├── FactorCalculationService.java      # Property/payroll/sales factor math
│   │   │   │   ├── SourcingRuleService.java           # Joyce/Finnigan, throwback logic
│   │   │   │   ├── NexusTrackingService.java          # Nexus determination
│   │   │   │   └── ApportionmentAuditService.java     # Audit trail
│   │   │   ├── repository/
│   │   │   │   ├── ScheduleYRepository.java
│   │   │   │   ├── PropertyFactorRepository.java
│   │   │   │   ├── PayrollFactorRepository.java
│   │   │   │   ├── SalesFactorRepository.java
│   │   │   │   ├── SaleTransactionRepository.java
│   │   │   │   └── NexusTrackingRepository.java
│   │   │   ├── model/
│   │   │   │   ├── ScheduleY.java                     # JPA entity
│   │   │   │   ├── PropertyFactor.java
│   │   │   │   ├── PayrollFactor.java
│   │   │   │   ├── SalesFactor.java
│   │   │   │   ├── SaleTransaction.java
│   │   │   │   ├── NexusTracking.java
│   │   │   │   └── ApportionmentAuditLog.java
│   │   │   ├── dto/
│   │   │   │   ├── ScheduleYRequest.java
│   │   │   │   ├── ScheduleYResponse.java
│   │   │   │   ├── FactorBreakdownDto.java
│   │   │   │   ├── ElectionUpdateDto.java
│   │   │   │   └── NexusStatusDto.java
│   │   │   ├── enums/
│   │   │   │   ├── ApportionmentFormula.java          # FOUR_FACTOR_DOUBLE_SALES, etc.
│   │   │   │   ├── SourcingMethod.java                # FINNIGAN, JOYCE
│   │   │   │   ├── ThrowbackElection.java             # THROWBACK, THROWOUT, NONE
│   │   │   │   ├── ServiceSourcingMethod.java         # MARKET_BASED, COST_OF_PERFORMANCE
│   │   │   │   └── SaleType.java                      # TANGIBLE_GOODS, SERVICES, etc.
│   │   │   └── validation/
│   │   │       └── ApportionmentValidator.java        # Factor range checks, consistency validation
│   │   └── integration/
│   │       └── RuleEngineClient.java                  # Fetch apportionment rules from Spec 4
│   └── test/java/com/munitax/taxengine/apportionment/
│       ├── service/
│       │   ├── ApportionmentServiceTest.java
│       │   ├── FactorCalculationServiceTest.java
│       │   ├── SourcingRuleServiceTest.java
│       │   └── NexusTrackingServiceTest.java
│       └── integration/
│           └── ApportionmentApiIntegrationTest.java

frontend/ (or components/ at repo root)
├── src/
│   ├── components/
│   │   ├── apportionment/
│   │   │   ├── ScheduleYForm.tsx                     # Main Schedule Y form
│   │   │   ├── PropertyFactorInput.tsx               # Property factor section
│   │   │   ├── PayrollFactorInput.tsx                # Payroll factor section
│   │   │   ├── SalesFactorInput.tsx                  # Sales factor section
│   │   │   ├── SaleTransactionList.tsx               # Detailed transaction table
│   │   │   ├── ApportionmentBreakdown.tsx            # Visual factor breakdown
│   │   │   ├── SourcingElectionPanel.tsx             # Joyce/Finnigan, throwback elections
│   │   │   ├── NexusTracker.tsx                      # State-by-state nexus status
│   │   │   └── ApportionmentSummary.tsx              # Final apportionment % display
│   │   └── shared/
│   │       ├── FactorPercentageDisplay.tsx           # Reusable factor % widget
│   │       └── TooltipExplainer.tsx                  # Help tooltips
│   ├── services/
│   │   ├── apportionmentService.ts                   # API client for apportionment endpoints
│   │   └── nexusService.ts                           # API client for nexus tracking
│   ├── types/
│   │   ├── apportionment.ts                          # TypeScript types matching DTOs
│   │   └── nexus.ts
│   └── utils/
│       ├── factorCalculation.ts                      # Client-side validation helpers
│       └── apportionmentValidation.ts                # Form validation rules
└── tests/
    ├── components/apportionment/
    │   ├── ScheduleYForm.test.tsx
    │   ├── ApportionmentBreakdown.test.tsx
    │   └── SourcingElectionPanel.test.tsx
    └── services/
        └── apportionmentService.test.ts
```

**Structure Decision**: Web application with microservices architecture. Frontend components in `components/apportionment/` directory, backend services in `backend/src/main/java/com/munitax/taxengine/apportionment/`. This feature extends the existing tax-engine-service rather than creating a new microservice, as apportionment is core tax calculation logic. Multi-tenant data isolation maintained via PostgreSQL schema-per-tenant pattern.

## Complexity Tracking

> **No violations to justify - Constitution Check passed**

All constitution principles satisfied:
- Uses existing tax-engine-service (no unnecessary microservice proliferation)
- Maintains multi-tenant schema isolation
- Provides comprehensive audit trail
- Enforces RBAC and encryption for sensitive data
- Progressive disclosure UI with error prevention
- 100% test coverage for critical path calculations

No complexity exceptions required.
