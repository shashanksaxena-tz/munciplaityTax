# GitHub Copilot Instructions - MuniTax Dublin Municipality Tax Calculator

## Project Overview

This is a multi-tenant municipal tax calculation system for Dublin, Ohio, built with:
- **Backend**: Java 21 + Spring Boot 3.2.3 microservices (9 services)
- **Frontend**: React 18 + TypeScript + Tailwind CSS
- **Database**: PostgreSQL 16 with tenant-scoped schemas (dublin.*, columbus.*)
- **Architecture**: Microservices with Eureka discovery, API Gateway, and Redis caching

## Current Focus: Withholding Reconciliation System

We're implementing a comprehensive W-1 withholding reconciliation system (Feature 1) with:
- W-1 filing with automatic cumulative YTD calculation
- Year-end W-2/W-3 reconciliation with discrepancy detection
- Amended W-1 filing with cascade updates
- Multi-frequency support (daily, semi-monthly, monthly, quarterly)
- AI-powered W-2 extraction integration

**Key Documents**:
- Specification: `specs/1-withholding-reconciliation/spec.md`
- Implementation Plan: `specs/1-withholding-reconciliation/plan.md`
- Data Model: `specs/1-withholding-reconciliation/data-model.md`
- API Contracts: `specs/1-withholding-reconciliation/contracts/`
- Research Decisions: `specs/1-withholding-reconciliation/research.md`

## Code Style & Conventions

### Java/Spring Boot Backend

1. **Entity Design**:
   - All entities MUST include `tenant_id` for multi-tenant isolation (Constitution II)
   - Use JPA annotations: `@Entity`, `@Table(name = "snake_case")`, `@Column`
   - Include audit fields: `created_at`, `updated_at`, `created_by`, `updated_by`
   - Example:
     ```java
     @Entity
     @Table(name = "w1_filings", schema = "${tenant.schema}")
     public class W1Filing {
         @Id
         @GeneratedValue(strategy = GenerationType.UUID)
         private UUID id;
         
         @Column(name = "tenant_id", nullable = false)
         private UUID tenantId;
         
         @Column(name = "business_id", nullable = false)
         private UUID businessId;
         
         // ... other fields
     }
     ```

2. **Service Layer**:
   - Use `@Service` annotation
   - Inject dependencies via constructor (no `@Autowired` on fields)
   - Use `@Transactional` for methods that modify data
   - Return DTOs, not entities
   - Example:
     ```java
     @Service
     public class W1FilingService {
         private final W1FilingRepository repository;
         
         public W1FilingService(W1FilingRepository repository) {
             this.repository = repository;
         }
         
         @Transactional
         public W1FilingResponse fileW1Return(W1FilingRequest request) {
             // Business logic
         }
     }
     ```

3. **Controller Layer**:
   - Use `@RestController` and `@RequestMapping`
   - Return `ResponseEntity<T>` for explicit status codes
   - Use `@Valid` for request validation
   - Example:
     ```java
     @RestController
     @RequestMapping("/api/v1/w1-filings")
     public class W1FilingController {
         private final W1FilingService service;
         
         @PostMapping
         public ResponseEntity<W1FilingResponse> fileW1Return(
             @Valid @RequestBody W1FilingRequest request
         ) {
             W1FilingResponse response = service.fileW1Return(request);
             return ResponseEntity.status(HttpStatus.CREATED).body(response);
         }
     }
     ```

4. **Repository Layer**:
   - Extend `JpaRepository<Entity, ID>`
   - Use query methods or `@Query` annotation
   - Scope all queries to tenant context
   - Example:
     ```java
     public interface W1FilingRepository extends JpaRepository<W1Filing, UUID> {
         List<W1Filing> findByBusinessIdAndTaxYear(UUID businessId, Integer taxYear);
         
         @Query("SELECT f FROM W1Filing f WHERE f.tenantId = :tenantId " +
                "AND f.businessId = :businessId AND f.taxYear = :taxYear")
         List<W1Filing> findFilings(@Param("tenantId") UUID tenantId, 
                                     @Param("businessId") UUID businessId,
                                     @Param("taxYear") Integer taxYear);
     }
     ```

### React/TypeScript Frontend

1. **Component Structure**:
   - Use functional components with hooks
   - Export component as default
   - Define props interface above component
   - Use TypeScript for all files (.tsx)
   - Example:
     ```typescript
     interface W1FilingWizardProps {
       businessId: string;
       onComplete: (filingId: string) => void;
     }
     
     export default function W1FilingWizard({ businessId, onComplete }: W1FilingWizardProps) {
       const [step, setStep] = useState(1);
       
       return (
         <div className="w1-filing-wizard">
           {/* Component JSX */}
         </div>
       );
     }
     ```

2. **API Integration**:
   - Use `services/api.ts` for all API calls
   - Use axios with bearer token authentication
   - Handle errors with try-catch
   - Example:
     ```typescript
     import api from '@/services/api';
     
     export const fileW1Return = async (request: W1FilingRequest): Promise<W1FilingResponse> => {
       try {
         const response = await api.post('/api/v1/w1-filings', request);
         return response.data;
       } catch (error) {
         console.error('Failed to file W-1:', error);
         throw error;
       }
     };
     ```

3. **State Management**:
   - Use React Context for global state (AuthContext, ProfileContext)
   - Use `useState` for component-local state
   - Use `useEffect` for side effects
   - Example:
     ```typescript
     const [filings, setFilings] = useState<W1Filing[]>([]);
     const [loading, setLoading] = useState(false);
     
     useEffect(() => {
       const loadFilings = async () => {
         setLoading(true);
         try {
           const data = await fetchW1Filings(businessId);
           setFilings(data);
         } finally {
           setLoading(false);
         }
       };
       loadFilings();
     }, [businessId]);
     ```

4. **Styling**:
   - Use Tailwind CSS utility classes
   - Follow existing color scheme (blue primary, gray neutral)
   - Use responsive design (mobile-first)
   - Example:
     ```tsx
     <div className="bg-white rounded-lg shadow-md p-6">
       <h2 className="text-2xl font-bold text-gray-900 mb-4">
         W-1 Filing
       </h2>
       <button className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
         Submit Filing
       </button>
     </div>
     ```

## Architecture Principles (Constitution)

### I. Microservices Architecture
- **Extend existing services** rather than creating new ones
- Current service: `tax-engine-service` (owns withholding domain)
- Service structure: domain/ (entities), service/ (business logic), controller/ (REST API), repository/ (data access)

### II. Multi-Tenant Data Isolation (NON-NEGOTIABLE)
- **Every entity** MUST have `tenant_id UUID NOT NULL`
- **Every query** MUST filter by tenant context
- Schema-per-tenant: `dublin.*`, `columbus.*`
- Use `@Filter` or explicit WHERE clauses

### III. Audit Trail Immutability
- Use `WithholdingAuditLog` entity marked `@Immutable`
- Log all actions: FILED, AMENDED, RECONCILED, PAYMENT_RECEIVED
- Store old/new values as JSONB
- Permanent retention (no deletion)

### IV. AI Transparency
- When using AI extraction (Gemini), include confidence scores
- For ignored W-2s, show extraction confidence + reason
- Example: `extractionConfidence: 0.85` with `reason: "WRONG_EIN"`

### V. Security First
- JWT authentication on all endpoints (`bearerAuth`)
- Validate tenant access in services
- Never expose tenant data cross-tenant
- Return 403 Forbidden for unauthorized access

### VI. User-Centric Design
- Provide field-level validation errors
- Use human-readable error messages
- Include help text and examples
- Show progress indicators for long operations

### VII. Test Coverage
- Write unit tests for services (JUnit 5 + Mockito)
- Write integration tests with TestContainers
- Write E2E tests for critical workflows (Playwright)
- Test error cases and edge cases

## Testing Guidelines

### Backend Tests

```java
// Unit Test Example
@ExtendWith(MockitoExtension.class)
class W1FilingServiceTest {
    @Mock
    private W1FilingRepository repository;
    
    @InjectMocks
    private W1FilingService service;
    
    @Test
    void shouldFileW1Return() {
        // Given
        W1FilingRequest request = new W1FilingRequest(/* ... */);
        
        // When
        W1FilingResponse response = service.fileW1Return(request);
        
        // Then
        assertNotNull(response.getId());
        assertEquals("FILED", response.getStatus());
    }
}

// Integration Test Example
@SpringBootTest
@Testcontainers
class WithholdingReconciliationIntegrationTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16");
    
    @Autowired
    private W1FilingService service;
    
    @Test
    void shouldReconcileW1AndW2Totals() {
        // File 4 quarterly W-1 returns
        // Upload W-2s
        // Verify reconciliation status
    }
}
```

### Frontend Tests

```typescript
// Component Test Example
import { render, screen, fireEvent } from '@testing-library/react';
import W1FilingWizard from './W1FilingWizard';

describe('W1FilingWizard', () => {
  it('should submit W-1 filing', async () => {
    render(<W1FilingWizard businessId="123" onComplete={jest.fn()} />);
    
    fireEvent.change(screen.getByLabelText('Gross Wages'), {
      target: { value: '50000' }
    });
    
    fireEvent.click(screen.getByText('Submit Filing'));
    
    await screen.findByText('Filing submitted successfully');
  });
});
```

## Common Patterns

### Event-Driven Updates
When W-1 is filed, publish event to update cumulative totals:

```java
// Publisher
@Service
public class W1FilingService {
    private final ApplicationEventPublisher eventPublisher;
    
    @Transactional
    public W1FilingResponse fileW1Return(W1FilingRequest request) {
        W1Filing filing = // ... save filing
        
        // Publish event
        eventPublisher.publishEvent(new W1FiledEvent(
            filing.getId(),
            filing.getBusinessId(),
            filing.getTaxYear(),
            filing.getGrossWages(),
            filing.getTaxDue()
        ));
        
        return toResponse(filing);
    }
}

// Consumer
@Component
public class CumulativeCalculationService {
    @EventListener
    @Transactional
    public void onW1Filed(W1FiledEvent event) {
        // Update cumulative totals
        updateCumulativeTotals(event.getBusinessId(), event.getTaxYear());
    }
}
```

### Cascade Updates for Amendments
When amended W-1 is filed, recalculate subsequent periods:

```java
@Transactional
public W1AmendmentResponse amendW1Filing(UUID filingId, W1AmendmentRequest request) {
    W1Filing original = repository.findById(filingId)
        .orElseThrow(() -> new NotFoundException("Filing not found"));
    
    // Create amended filing
    W1Filing amended = createAmendedFiling(original, request);
    repository.save(amended);
    
    // Batch update subsequent periods
    int updatedCount = updateSubsequentPeriods(
        original.getBusinessId(),
        original.getTaxYear(),
        original.getPeriodEndDate()
    );
    
    return new W1AmendmentResponse(amended, updatedCount);
}
```

## Performance Targets

- W-1 filing submission: **< 2 seconds**
- Cumulative totals query: **< 80ms** (cached in Redis)
- Year-end reconciliation: **< 10 seconds** (up to 52 filings)
- Dashboard load: **< 1 second**

## File Locations

- Backend services: `backend/{service-name}/src/main/java/com/munitax/{service}/`
- Frontend components: `components/`
- API services: `services/api.ts`
- Types: `types.ts`
- Specs: `specs/1-withholding-reconciliation/`

## Environment Variables

- `TENANT_SCHEMA`: Current tenant schema (dublin, columbus)
- `DATABASE_URL`: PostgreSQL connection string
- `REDIS_URL`: Redis connection string
- `JWT_SECRET`: JWT signing secret
- `GEMINI_API_KEY`: Google Gemini API key for extraction

## Useful Commands

```bash
# Backend
cd backend/tax-engine-service
mvn clean install
mvn test
mvn spring-boot:run

# Frontend
npm install
npm run dev
npm test
npm run build

# Docker
docker-compose up -d
docker-compose logs -f tax-engine-service
docker-compose restart tax-engine-service
```

## When in Doubt

1. Check the specification: `specs/1-withholding-reconciliation/spec.md`
2. Review data model: `specs/1-withholding-reconciliation/data-model.md`
3. Check API contracts: `specs/1-withholding-reconciliation/contracts/`
4. Follow research decisions: `specs/1-withholding-reconciliation/research.md`
5. Follow constitution principles in `plan.md`
